.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Inline::CPP 3pm"
.TH Inline::CPP 3pm "2003-08-12" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Inline::CPP \- Write Perl subroutines and classes in C++.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Inline CPP;
\&
\&   print "9 + 16 = ", add(9, 16), "\en";
\&   print "9 \- 16 = ", subtract(9, 16), "\en";
\&
\&   _\|_END_\|_
\&   _\|_CPP_\|_
\&
\&   int add(int x, int y) { 
\&      return x + y;
\&   }
\&
\&   int subtract(int x, int y) {
\&      return x \- y;
\&   }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Inline::CPP\*(C'\fR module allows you to put \*(C+ source code directly
\&\*(L"inline\*(R" in a Perl script or module. You code classes or functions in
\&\*(C+, and you can use them as if they were written in Perl.
.SH "Choosing a \*(C+ Compiler"
.IX Header "Choosing a  Compiler"
Inline::CPP just parses your \*(C+ code and creates bindings to it. Like 
Inline::C, you will need a suitable compiler the first time you run the
script. Choosing a \*(C+ compiler can prove difficult, because Perl is 
written in C, not \*(C+.
.PP
Here's the rule: use any \*(C+ compiler that's compatible with the compiler
which built perl. For instance, if perl was built with \f(CW\*(C`gcc\*(C'\fR, use \f(CW\*(C`g++\*(C'\fR.
If you're on a Sun or an \s-1IRIX\s0 box and the system C compiler \f(CW\*(C`cc\*(C'\fR built perl,
then use the system \*(C+ compiler, \f(CW\*(C`CC\*(C'\fR.
.PP
Some compilers actually compile both C and \*(C+ with the same compiler. 
Microsoft's \f(CW\*(C`cl.exe\*(C'\fR is one such compiler \*(-- you pass it the <\-TP> flag
to convince it that you want \*(C+ mode.
.SH "Using Inline::CPP"
.IX Header "Using Inline::CPP"
Inline::CPP is very similar to Inline::C. It uses a grammar to
parse your \*(C+ code, and binds to functions or classes which are
recognized. If a function is recognized, it will be available from
Perl space. If the function's signature is not recognized, it will not
be available from Perl space, but will be available from other
functions in \*(C+.
.PP
For more information about the grammar used to parse \*(C+ code, see the
section called \*(L"Grammar\*(R".
.PP
The following example shows how \*(C+ snippets map into the Perl
namespace:
.PP
Example 1:
.PP
.Vb 1
\&   use Inline CPP => <<\*(AqEND\*(Aq;
\&
\&   int doodle() { }
\&
\&   class Foo {
\&     public:
\&       Foo();
\&       ~Foo();
\&
\&       int get_data() { return data; }
\&       void set_data(int a) { data = a; }
\&     private:
\&       int data;
\&   };
\&
\&   Foo::Foo() { cout << "creating a Foo()" << endl; }
\&   Foo::~Foo() { cout << "deleting a Foo()" << endl; }
\&
\&   END
.Ve
.PP
After running the code above, Perl's namespace would look similar to if
following code had been run:
.PP
.Vb 1
\&   sub main::doodle { }
\&
\&   package main::Foo;
\&
\&   sub new { print "creating a Foo()\en"; bless {}, shift }
\&   sub DESTROY { print "deleting a Foo()\en" }
\&
\&   sub get_data { my $o=shift; $o\->{data} }
\&   sub set_data { my $o=shift; $o\->{data} = shift }
.Ve
.PP
The difference, of course, is that in the latter, Perl does the work. In the
Inline::CPP example, all function calls get sent off to your \*(C+ code. That
means that things like this won't work:
.PP
.Vb 2
\&   my $obj = new Foo;
\&   $obj\->{extrafield} = 10;
.Ve
.PP
It doesn't work because \f(CW$obj\fR is not a blessed hash. It's a blessed
reference to a \*(C+ object (and anyway, \*(C+ wouldn't let you do that either,
since extrafield wasn't defined).
.SH "\*(C+ Configuration Options"
.IX Header " Configuration Options"
For information on how to specify Inline configuration options, see
Inline. This section describes each of the configuration options
available for C. Most of the options correspond either the MakeMaker
or \s-1XS\s0 options of the same name. See ExtUtils::MakeMaker and
perlxs.
.SS "\s-1ALTLIBS\s0"
.IX Subsection "ALTLIBS"
Adds a new entry to the end of the list of alternative libraries to 
bind with. MakeMaker will search through this list and use the first
entry where all the libraries are found.
.PP
.Vb 1
\&   use Inline Config => ALTLIBS => \*(Aq\-L/my/other/lib \-lfoo\*(Aq;
.Ve
.PP
See also the \s-1LIBS\s0 config option, which appends to the last entry in
the list.
.SS "\s-1AUTO_INCLUDE\s0"
.IX Subsection "AUTO_INCLUDE"
Specifies extra statements to be automatically included. They will be
added on to the defaults. A newline char will automatically be added.
.PP
.Vb 1
\&   use Inline Config => AUTO_INCLUDE => \*(Aq#include "something.h"\*(Aq;
.Ve
.SS "\s-1BOOT\s0"
.IX Subsection "BOOT"
Specifies code to be run when your code is loaded. May not contain any
blank lines. See perlxs for more information.
.PP
.Vb 1
\&   use Inline Config => BOOT => \*(Aqfoo();\*(Aq;
.Ve
.SS "\s-1CC\s0"
.IX Subsection "CC"
Specifies which compiler to use.
.SS "\s-1CCFLAGS\s0"
.IX Subsection "CCFLAGS"
Specifies extra compiler flags. Corresponds to the MakeMaker option.
.SS "\s-1FILTERS\s0"
.IX Subsection "FILTERS"
Specifies one (or more, in an array ref) filter which is to be applied to 
the code just prior to parsing. The filters are executed one after another,
each operating on the output of the previous one. You can pass in a code
reference or the name of a prepackaged filter.
.PP
.Vb 1
\&   use Inline Config => FILTERS => [Strip_POD => \e&myfilter];
.Ve
.PP
The filter may do anything. The code is passed as the first argument, and
it returns the filtered code.
.SS "\s-1INC\s0"
.IX Subsection "INC"
Specifies extra include directories. Corresponds to the MakeMaker
parameter.
.PP
.Vb 1
\&   use Inline Config => INC => \*(Aq\-I/my/path\*(Aq;
.Ve
.SS "\s-1LD\s0"
.IX Subsection "LD"
Specifies the linker to use.
.SS "\s-1LDDLFLAGS\s0"
.IX Subsection "LDDLFLAGS"
Specifies which linker flags to use.
.PP
\&\s-1NOTE:\s0 These flags will completely override the existing flags, instead
of just adding to them. So if you need to use those too, you must
respecify them here.
.SS "\s-1LIBS\s0"
.IX Subsection "LIBS"
Specifies external libraries that should be linked into your
code. Corresponds to the MakeMaker parameter.
.PP
.Vb 1
\&   use Inline Config => LIBS => \*(Aq\-L/your/path \-lyourlib\*(Aq;
.Ve
.PP
Unlike the \s-1LIBS\s0 configuration parameter used in Inline::C, successive
calls to \s-1LIBS\s0 append to the previous calls. For example,
.PP
.Vb 1
\&   use Inline Config => LIBS => \*(Aq\-L/my/path\*(Aq, LIBS => \*(Aq\-lyourlib\*(Aq;
.Ve
.PP
will work correctly. If you want to add a new element to the list of 
possible libraries to link with, use the Inline::CPP configuration \s-1ALTLIBS\s0.
.SS "\s-1MAKE\s0"
.IX Subsection "MAKE"
Specifies the name of the 'make' utility to use.
.SS "\s-1MYEXTLIB\s0"
.IX Subsection "MYEXTLIB"
Specifies a user compiled object that should be linked in. Corresponds
to the MakeMaker parameter.
.PP
.Vb 1
\&   use Inline Config => MYEXTLIB => \*(Aq/your/path/something.o\*(Aq;
.Ve
.SS "\s-1PREFIX\s0"
.IX Subsection "PREFIX"
Specifies a prefix that will automatically be stripped from \*(C+
functions when they are bound to Perl. Less useful than in C, because
\&\*(C+ mangles its function names so they don't conflict with C functions
of the same name.
.PP
.Vb 1
\&   use Inline Config => PREFIX => \*(AqZLIB_\*(Aq;
.Ve
.PP
This only affects \*(C+ function names, not \*(C+ class names or methods.
.SS "\s-1PRESERVE_ELLIPSIS\s0"
.IX Subsection "PRESERVE_ELLIPSIS"
By default, Inline::CPP replaces \f(CW\*(C`...\*(C'\fR in bound functions with three 
spaces, since the arguments are always passed on the Perl Stack, not on
the C stack. This is usually desired, since it allows functions with
no fixed arguments (most compilers require at least one fixed argument).
.PP
.Vb 3
\&   use Inline Config => PRESERVE_ELLIPSIS => 1;
\&or
\&   use Inline Config => ENABLE => PRESERVE_ELLIPSIS;
.Ve
.PP
For an example of why \s-1PRESERVE_ELLIPSIS\s0 is normally not needed, see the 
examples section, below.
.SS "\s-1STD_IOSTREAM\s0"
.IX Subsection "STD_IOSTREAM"
By default, Inline::CPP includes \f(CW\*(C`iostream.h\*(C'\fR at the top of your code.
This option makes it include \f(CW\*(C`iostream\*(C'\fR instead, which is the
ANSI-compliant version of the header. Usually, these include files are
not compatible with one another.
.PP
.Vb 1
\&   use Inline CPP => Config => ENABLE => STD_IOSTREAM;
.Ve
.SS "\s-1STRUCTS\s0"
.IX Subsection "STRUCTS"
Specifies whether to bind C structs into Perl using Inline::Struct. 
\&\s-1NOTE:\s0 Support for this option is experimental. Inline::CPP already binds
to structs defined in your code. Structs and classes are treated as the
same construct, except that a struct's initial scope is public, not 
private. Inline::Struct provides autogenerated get/set methods, an 
overloaded constructor, and several other features not available in
Inline::CPP.
.PP
You can invoke \s-1STRUCTS\s0 in several ways:
.PP
.Vb 3
\&   use Inline Config => STRUCTS => \*(AqFoo\*(Aq;
\&or
\&   use Inline Config => STRUCTS => [\*(AqBar\*(Aq, \*(AqBaz\*(Aq];
.Ve
.PP
Binds the named structs to Perl. Emits warnings if a struct was requested 
but could not be bound for some reason.
.PP
.Vb 3
\&   use Inline Config => ENABLE => \*(AqSTRUCTS\*(Aq;
\&or
\&   use Inline Config => STRUCTS => 1;
.Ve
.PP
Enables binding structs to Perl. All structs which can be bound, will. This
parameter overrides all requests for particular structs.
.PP
.Vb 3
\&   use Inline Config => DISABLE => \*(AqSTRUCTS\*(Aq;
\&or
\&   use Inline Config => STRUCTS => 0;
.Ve
.PP
Disables binding structs to Perl. Overrides any other settings.
.PP
See Inline::Struct for more details about how \f(CW\*(C`Inline::Struct\*(C'\fR
binds C structs to Perl.
.SS "\s-1TYPEMAPS\s0"
.IX Subsection "TYPEMAPS"
Specifies extra typemap files to use. These types will modify the
behaviour of \*(C+ parsing. Corresponds to the MakeMaker parameter.
.PP
.Vb 1
\&   use Inline Config => TYPEMAPS => \*(Aq/your/path/typemap\*(Aq;
.Ve
.SH "\*(C+\-Perl Bindings"
.IX Header "-Perl Bindings"
This section describes how the \f(CW\*(C`Perl\*(C'\fR variables get mapped to \f(CW\*(C`C++\*(C'\fR
variables and back again.
.PP
Perl uses a stack to pass arguments back and forth to subroutines. When
a sub is called, it pops off all its arguments from the stack; when it's
done, it pushes its return values back onto the stack.
.PP
\&\s-1XS\s0 (Perl's language for creating C or \*(C+ extensions for Perl) uses
\&\*(L"typemaps\*(R" to turn SVs into C types and back again. This is done through
various \s-1XS\s0 macro calls, casts, and the Perl \s-1API\s0. \s-1XS\s0 also allows you to
define your own mappings.
.PP
\&\f(CW\*(C`Inline::CPP\*(C'\fR uses a much simpler approach. It parses the system's
typemap files and only binds to functions with supported types. You 
can tell \f(CW\*(C`Inline::CPP\*(C'\fR about custom typemap files too.
.PP
If you have very complicated data structures in either \*(C+ or Perl,
you should just pass them as an SV* and do the conversion yourself in
your \*(C+ function.
.PP
In \*(C+, a struct is a class whose default scope is public, not
private.  Inline::CPP binds to structs with this in mind \*(-- get/set
methods are not yet auto-generated (although they are scheduled to
land in an upcoming release).
.PP
If you have a C struct, you can use Inline::Struct to allow Perl
complete access to the internals of the struct. You can create and
modify structs from inside Perl, as well as pass structs into \*(C+
functions and return them from functions. Please note that
Inline::Struct does not understand any \*(C+ features, so constructors
and member functions are not supported. See Inline::Struct for more
details.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Here are some examples.
.SS "Example 1 \- Farmer Bob"
.IX Subsection "Example 1 - Farmer Bob"
This example illustrates how to use a simple class (\f(CW\*(C`Farmer\*(C'\fR) from
Perl. One of the new features in Inline::CPP is binding to classes
with inline method definitions:
.PP
.Vb 1
\&   use Inline CPP;
\&
\&   my $farmer = new Farmer("Ingy", 42);
\&   my $slavedriver = 1;
\&   while($farmer\->how_tired < 420) {
\&     $farmer\->do_chores($slavedriver);
\&     $slavedriver <<= 1;
\&   }
\&
\&   print "Wow! The farmer worked ", $farmer\->how_long, " hours!\en";
\&
\&   _\|_END_\|_
\&   _\|_CPP_\|_
\&
\&   class Farmer {
\&   public:
\&     Farmer(char *name, int age);
\&     ~Farmer();
\&
\&     int how_tired() { return tiredness; }
\&     int how_long() { return howlong; }
\&     void do_chores(int howlong);
\&
\&   private:
\&     char *name;
\&     int age;
\&     int tiredness;
\&     int howlong;
\&   };
\&
\&   Farmer::Farmer(char *name, int age) {
\&     this\->name = strdup(name);
\&     this\->age = age;
\&     tiredness = 0;
\&     howlong = 0;
\&   }
\&
\&   Farmer::~Farmer() {
\&     free(name);
\&   }
\&
\&   void Farmer::do_chores(int hl) {
\&     howlong += hl;
\&     tiredness += (age * hl);
\&   }
.Ve
.SS "Example 2 \- Plane and Simple"
.IX Subsection "Example 2 - Plane and Simple"
This example demonstrates some new features of Inline::CPP: support for
inheritance and abstract classes. The defined methods of the abstract 
class \f(CW\*(C`Object\*(C'\fR are bound to Perl, but there is no constructor or 
destructor, meaning you cannot instantiate an \f(CW\*(C`Object\*(C'\fR.
.PP
The \f(CW\*(C`Airplane\*(C'\fR is a fully-bound class which can be created and
manipulated from Perl.
.PP
.Vb 1
\&   use Inline CPP;
\&
\&   my $plane = new Airplane;
\&   $plane\->print;
\&   if ($plane\->isa("Object")) { print "Plane is an Object!\en"; }
\&   unless ($plane\->can("fly")) { print "This plane sucks!\en"; }
\&
\&   _\|_END_\|_
\&   _\|_CPP_\|_
\&
\&   /* Abstract class (interface) */
\&   class Object {
\&   public:
\&     virtual void print() { cout << "Object (" << this << ")" << endl; }
\&     virtual void info() = 0;
\&     virtual bool isa(char *klass) = 0;
\&     virtual bool can(char *method) = 0;
\&   };
\&
\&   class Airplane : public Object {
\&   public:
\&     Airplane() {}
\&     ~Airplane() {}
\&
\&     virtual void info() { print(); }
\&     virtual bool isa(char *klass) { return strcmp(klass, "Object")==0; }
\&     virtual bool can(char *method) { 
\&       bool yes = false;
\&       yes |= strcmp(method, "print")==0;
\&       yes |= strcmp(method, "info")==0;
\&       yes |= strcmp(method, "isa")==0;
\&       yes |= strcmp(method, "can")==0;
\&       return yes;
\&     }
\&   };
.Ve
.SS "Example 3 \- The Ellipsis Abridged"
.IX Subsection "Example 3 - The Ellipsis Abridged"
One of the big advantages of Perl over C or \*(C+ is the ability to pass an 
arbitrary number of arguments to a subroutine. You can do it in C, but it's 
messy and difficult to get it right. All of this mess is necessary because
C doesn't give the programmer access to the stack. Perl, on the other hand,
gives you access to everything.
.PP
Here's a useful function written in Perl that is relatively slow:
.PP
.Vb 9
\&   sub average { 
\&      my $average = 0;
\&      for (my $i=0; $i<@_; $i++) {
\&         $average *= $i;
\&         $average += $_[$i];
\&         $average /= $i + 1;
\&      }
\&      return $average;
\&   }
.Ve
.PP
Here's the same function written in C:
.PP
.Vb 10
\&   double average() {
\&      Inline_Stack_Vars;
\&      double avg = 0.0;
\&      for (int i=0; i<Inline_Stack_Items; i++) {
\&         avg *= i;
\&         avg += SvNV(Inline_Stack_Item(i));
\&         avg /= i + 1;
\&      }
\&      return avg;
\&   }
.Ve
.PP
Here's a benchmark program that tests which is faster:
.PP
.Vb 11
\&   use Inline CPP;
\&   my @numbers = map { rand } (1 .. 10000);
\&   my ($a, $stop);
\&   $stop = 200;
\&   if (@ARGV) {
\&      $a = avg(@numbers) while $stop\-\-;
\&   }
\&   else {
\&      $a = average(@numbers) while $stop\-\-;
\&   }
\&   print "The average of 10000 random numbers is: ", $a, "\en";
\&
\&   sub average {
\&       my $average = 0;
\&       for (my $i=0; $i<@_; $i++) {
\&           $average *= $i;
\&           $average += $_[$i];
\&           $average /= $i + 1;
\&       }
\&       return $average;
\&   }
\&
\&   _\|_END_\|_
\&   _\|_CPP_\|_
\&
\&   double avg(...) {
\&       Inline_Stack_Vars;
\&       double avg = 0.0;
\&       for (int i=0; i<items; i++) {
\&           avg *= i;
\&           avg += SvNV(ST(i));
\&           avg /= i + 1;
\&       }
\&       return avg;
\&   }
.Ve
.PP
The perl sub runs in 14.18 seconds, an average of 0.0709s per call.
The C function runs in 1.52 seconds, an average of 0.0076s per call.
Mind you, those both include the time taken to initialize the array with
random numbers. And by varying the number of elements in the array and the
number of repetitions of the function, we can change this number a lot.
.PP
What's the point? Of \fBcourse\fR C or \*(C+ is faster than Perl. Well..., actually,
that wasn't really the point; that was an aside. Look at the function 
declaration:
.PP
.Vb 1
\&   double avg(...)
.Ve
.PP
Why didn't we need to use varargs macros to get at the arguments? Why didn't 
the compiler complain that there were no required arguments? Because 
Inline::\*(C+ actually compiled this:
.PP
.Vb 1
\&   double avg(   )
.Ve
.PP
When it bound to the function, it noticed the ellipsis and decided to get rid
of it. Any function bound to Perl that has an ellipsis in it will have its 
arguments passed via the Perl stack, not the C stack. That means if you write
a function like this:
.PP
.Vb 1
\&   void myprintf(char *format, ...);
.Ve
.PP
then you'd better be reading things from the Perl stack. If you aren't, then
specify the \s-1PRESERVE_ELLIPSIS\s0 option in your script. That will leave the 
ellipsis in the code for the compiler to whine about. :)
.SS "Example 4 \- Stacks and Queues"
.IX Subsection "Example 4 - Stacks and Queues"
Everyone who learns \*(C+ writes a stack and queue class sooner or
later. I might as well try it from Inline. But why reinvent the wheel?
Perl has a perfectly good Array type, which can easily implement both
a Queue and a Stack.
.PP
This example implements a Queue and a Stack class, and shows off just 
a few more new features of Inline::CPP: default values to arguments,
.PP
.Vb 1
\&   use Inline CPP;
\&
\&   my $q = new Queue;
\&   $q\->q(50);
\&   $q\->q("Where am I?");
\&   $q\->q("In a queue.");
\&   print "There are ", $q\->size, " items in the queue\en";
\&   while($q\->size) {
\&     print "About to dequeue:  ", $q\->peek, "\en";
\&     print "Actually dequeued: ", $q\->dq, "\en";
\&   }
\&
\&   my $s = new Stack;
\&   $s\->push(42);
\&   $s\->push("What?");
\&   print "There are ", $s\->size, " items on the stack\en";
\&   while($s\->size) {
\&     print "About to pop:    ", $s\->peek, "\en";
\&     print "Actually popped: ", $s\->pop, "\en";
\&   }
\&
\&   _\|_END_\|_
\&   _\|_CPP_\|_
\&
\&   class Queue {
\&   public:
\&     Queue(int sz=0) { q = newAV(); if (sz) av_extend(q, sz\-1); }
\&     ~Queue() { av_undef(q); }
\&
\&     int size() {return av_len(q) + 1; }
\&
\&     int q(SV *item) { av_push(q, SvREFCNT_inc(item)); return av_len(q)+1; }
\&     SV *dq() { return av_shift(q); }
\&     SV *peek() { return size() ? SvREFCNT_inc(*av_fetch(q,0,0)): &PL_sv_undef;}
\&
\&   private:
\&     AV *q;
\&   };
\&
\&   class Stack {
\&   public:
\&     Stack(int sz=0) { s = newAV(); if (sz) av_extend(s, sz\-1); }
\&     ~Stack() { av_undef(s); }
\&
\&     int size() { return av_len(s) + 1; }
\&
\&     int push(SV *i) { av_push(s, SvREFCNT_inc(i)); return av_len(s)+1; }
\&     SV *pop() { return av_pop(s); }
\&     SV *peek() { return size() ? SvREFCNT_inc(*av_fetch(s,size()\-1,0)) : &PL_sv_undef; }
\&
\&   private:
\&     AV *s;
\&   };
.Ve
.SH "Grammar Details"
.IX Header "Grammar Details"
Perl 5.6.0 is recommended for Inline::CPP, and is required to get all the 
new features. If you are using Perl 5.005_03 the package will build and run, 
but you will have problems in certain circumstances:
.SS "Inline function definitions"
.IX Subsection "Inline function definitions"
For the purposes of this discussion, inline function definitions are best
described by this example:
.PP
.Vb 4
\&   class Foo {
\&     public:
\&       Foo() { /* Do something */ }
\&   };
.Ve
.PP
This example shows a class with a constructor defined inline. Inline::CPP can
parse this example with 5.005. But this example requires Perl 5.6.0:
.PP
.Vb 4
\&   class Foo {
\&     public:
\&       Foo() { if(1) { /* Do something */ } }
\&   };
.Ve
.PP
Here's what happened: Inline::CPP saw a class, saw the method, then noticed
it was an inline method. So it grabbed this text:
.PP
.Vb 1
\&   "{ if(1) { /* Do something */ }"
.Ve
.PP
And then it tried to match another part of the class. But it failed because 
the next part of the string is this (with newlines trimmed):
.PP
.Vb 1
\&   "} };"
.Ve
.PP
The remaining text doesn't parse right. There are two solutions:
.IP "a" 4
.IX Item "a"
Use Perl version 5.6.0 or better; or,
.IP "b" 4
.IX Item "b"
Move the definition outside the class.
.SS "Complex default parameters"
.IX Subsection "Complex default parameters"
Again, default parameters are best described by example:
.PP
.Vb 1
\&   int root(double number, int whatroot=2);
.Ve
.PP
This function takes one or two arguments. If the second is missing, \*(C+ gives
it the value 2. Inline::CPP can parse this simple example regardless of your 
perl version. But the following example requires 5.6.0:
.PP
.Vb 1
\&   int root(double number, int whatroot=((2)));
.Ve
.PP
That's because if you're using 5.005, your arguments are parsed with a regular
expression that looks for only one closing parenthesis. Any more than that, 
and you get a parse error.
.PP
Again, there are two solutions:
.IP "a" 4
.IX Item "a"
Use Perl version 5.6.0 or better; or,
.IP "b" 4
.IX Item "b"
Make the strange expression a constant or macro and use that.
.SS "Rant: Perl 5.005 is for Dummies"
.IX Subsection "Rant: Perl 5.005 is for Dummies"
I'm going to take the opportunity to rant. Everything in the rest of this
section can be ignored if you don't want to hear it.
.PP
Perl 5.6.0 has been out for a long time. It's proven, stable, and people use 
it all the time. Perl 5.6.1 is the latest stable release. Unless you depend 
on one of the few modules which are only available for the ancient versions of 
Perl, there is \fBabsolutely no reason\fR not to upgrade today!
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For general information about how \f(CW\*(C`Inline\*(C'\fR binds code to Perl, see
Inline.
.PP
For information on using C with Perl, see Inline::C and
Inline::C\-Cookbook. For \f(CW\*(C`WMTYEWTK\*(C'\fR, see perlxs,
perlxstut, perlapi, and perlguts.
.PP
For information on using C and \*(C+ structs with Perl, see 
Inline::Struct.
.SH "BUGS AND DEFICIENCIES"
.IX Header "BUGS AND DEFICIENCIES"
When reporting a bug, please do the following:
.PP
.Vb 4
\& \- Put "use Inline REPORTBUG;" at the top of your code, or 
\&   use the command line option "perl \-MInline=REPORTBUG ...".
\& \- Run your code.
\& \- Follow the printed instructions.
.Ve
.PP
Here are some things to watch out for:
.IP "1." 4
The grammar used for parsing \*(C+ is still quite simple, and does not allow
several features of \*(C+:
.RS 4
.IP "a" 4
.IX Item "a"
templates
.IP "b" 4
.IX Item "b"
operator overloading
.IP "c" 4
.IX Item "c"
function overloading
.RE
.RS 4
.Sp
Other grammar problems will probably be noticed quickly.
.RE
.IP "2." 4
In order of relative importance, improvements planned in the near
future are:
.RS 4
.IP "a" 4
.IX Item "a"
support for overloaded functions and methods
.IP "b" 4
.IX Item "b"
binding to constants and constant #defines
.IP "c" 4
.IX Item "c"
binding to unions
.IP "d" 4
.IX Item "d"
autogenerated get/set methods on public members
.RE
.RS 4
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
Neil Watkiss <NEILW@cpan.org>
.PP
Brian Ingerson <INGY@cpan.org> is the author of \f(CW\*(C`Inline\*(C'\fR,
\&\f(CW\*(C`Inline::C\*(C'\fR and \f(CW\*(C`Inline::CPR\*(C'\fR. He is known in the innermost Inline
circles as \*(L"Batman\*(R". ;)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000 \- 2001, Neil Watkiss.
.PP
All Rights Reserved. This module is free software. It may be used,
redistributed and/or modified under the same terms as Perl itself.
.PP
See http://www.perl.com/perl/misc/Artistic.html
